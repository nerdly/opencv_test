/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package opencv_test;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.opencv.core.Core;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Point;
import org.opencv.core.Rect;
import org.opencv.core.Scalar;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.Imgproc;
import org.opencv.videoio.VideoCapture;
import org.opencv.core.Size;


public class App {
    // Load the native code library for OpenCV from the gradle lib.
    static{ nu.pattern.OpenCV.loadLocally(); }

    // Define the area of the captured picture to look at.
    private static Point TOPLEFT_ANCHOR_POINT = new Point(250,200);
    private static Point BOTTOMRIGHT_ANCHOR_POINT = new Point(300,275);

    /**
     * Main program function, execution starts here.
     * @param args string array of command line arguments. Not used.
     */
    public static void main(String[] args) {
        System.out.println("Welcome to OpenCV " + Core.VERSION);

        // create image capture for zeroth web cam.
        //VideoCapture vc = new VideoCapture(0);
        Mat image = Imgcodecs.imread("C:/Users/matth/OneDrive/Documents/Robotics/opencv_test/9in.jpg" ); 
        //writeImage(image, "original");

        PolePosition position = findPolePosition(image);
        
        System.out.println(position);

        Point tl = new Point((image.width()/2) + position.getOffsetFromCenter() - (position.getWidth()/2), 0);
        Point br = new Point((image.width()/2) + position.getOffsetFromCenter() + (position.getWidth()/2), image.height());
        Imgproc.rectangle(image, tl, br,new Scalar(0,255,0) , 10);

        Imgproc.line(image, new Point((image.width()/2) + position.getOffsetFromCenter(), 0), new Point((image.width()/2) + position.getOffsetFromCenter(), image.height()), new Scalar(255,0,0));
        writeImage(image, "Biggest");

        // find focal length
        //double focalLength = 1371.5; // (bounds.width * 6.5);
        

        // find width
       //double KNOWN_WIDTH = 1.0; // in

        //double distance = (focalLength) / bounds.width;
        //System.out.println("Distance (inches): " + distance + " with focal length " + focalLength);

        //double pixelangle = 60.0 / image.width();
        //double offsetangle = pixelangle * offset;

        //System.out.println("Offset angle = " + offsetangle + " with pixel angle = " + pixelangle);

        // // Calculate angle
        // // Sin theta = opposite over hypotenuse
        // // hypotenuse = distance
        // // opposite = offset * distance
        // double opposite = offset * distance;
        // double sintheta = opposite/distance;
        // double theta = Math.asin(sintheta);

        // System.out.println("Sin Theta = " + sintheta + " theta = " + theta + " Opposite = " + opposite);
    }

    /**
     * Writes out the image to a file in a specific directory.
     * 
     * File is named with current date/time stamp plus a provided label.
     * 
     * @param image The Mat of the image to print
     * @param label The label to include in the filename.
     */
    public static void writeImage(Mat image, String label)
    {
        // Generate name
        String name = "C:/Users/matth/OneDrive/Documents/Robotics/images/"  + new SimpleDateFormat( 
            "yyyy-MM-dd-hh-mm-ss") 
            .format(new Date( )) + label + ".jpg";

        // note filename to output
        System.out.println("Saving capture to " + name);

        // Write to file 
        Imgcodecs.imwrite(name, image); 
    }

    static MatOfPoint  findLargestContour(Mat image)
    {
         // transform the image data into yCrCb color format.
         Mat yCrCb = new Mat();
         Imgproc.cvtColor(image, yCrCb, Imgproc.COLOR_BGR2YCrCb);
 
         // Extract the red channel and save for reference.
         Mat red = new Mat();
         Core.extractChannel(yCrCb, red, 2);
        // writeImage(red, "red");
 
         Scalar redtop = new Scalar(60,0, 0);
         Scalar redbottom = new Scalar(0, 0, 0);
         Mat ycrcbmask = new Mat();
         Core.inRange(red, redbottom, redtop, ycrcbmask);
         
 
        // writeImage(ycrcbmask, "ycrcbmask");
 
         Mat blurred = new Mat();
         Size kernelsize = new Size(15,15);
         Imgproc.GaussianBlur(ycrcbmask, blurred, kernelsize, 0);
 
         Mat threshold = new Mat();
         Imgproc.threshold(blurred, threshold,  127, 255, Imgproc.THRESH_BINARY);
 
        // writeImage(blurred, "blurry");
 
         List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
         Imgproc.findContours(blurred, contours, threshold, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);
         System.out.println("Found " + contours.size() + " Contours");
 
         // find biggest contour
 
         int indexOfMaxArea = 0;
         double maxArea = 0;
         
         for(int i = 0; i < contours.size(); i++)
         {   
             double areaOfCurrentContour = Imgproc.contourArea(contours.get(i));
             Rect bounds = Imgproc.boundingRect(contours.get(i));
             //System.out.println("contour " + i + " width " + bounds.width + " height " + bounds.height + " cols " + contours.get(i).cols() + " rows " + contours.get(i).rows() + " continuous " + contours.get(i).isContinuous() + " area " + areaOfCurrentContour);
             if(areaOfCurrentContour > maxArea)
             {
                 maxArea = areaOfCurrentContour;
                 indexOfMaxArea = i;
             }
             //Imgproc.drawContours(contimg, contours, i, new Scalar(0,255,0),11);
 
         }

        return contours.get(indexOfMaxArea);
    }

    static PolePosition findPolePosition(Mat image)
    {
        MatOfPoint largestContour = findLargestContour(image);
        Rect bounds = Imgproc.boundingRect(largestContour);
        // Find center of biggest contour
        int center = bounds.x + (bounds.width/2);
        int centerOfImage = image.width() / 2;
        int offset = Math.abs(center - centerOfImage);
        // System.out.println("Center of contour: " + center);
        // System.out.println("Center of image " + centerOfImage);
        // System.out.println("Offset: " + offset);

        return new PolePosition(bounds.width, offset);
    }
}
